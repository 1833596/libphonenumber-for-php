<?php
namespace libphonenumber\build;

require_once __DIR__ . '/BuildMetadataFromXml.php';

use libphonenumber\PhoneMetadata;

/**
 * Tool to convert phone number metadata from the XML format to protocol buffer format.
 *
 * @author Davide Mendolia
 */
class BuildMetadataPHPFromXml
{
    const HELP_MESSAGE = <<<'EOT'
  Usage:
  BuildMetadataProtoFromXml <inputFile> <outputDir> <dataPrefix> <mappingClass> [<liteBuild>]
  
  where:
    inputFile    The input file containing phone number metadata in XML format.
    outputDir    The output source directory to store phone number metadata in proto
                 format (one file per region) and the country code to region code
                 mapping file.
    dataPrefix   The start of the filename to store the files (eg. dataPrefix_GB.php)
    mappingClass The name of the mapping class generated
    liteBuild    Whether to generate the lite-version of the metadata (default:
                 false). When set to true certain metadata will be omitted.
                 At this moment, example numbers information is omitted.
EOT;
    const GENERATION_COMMENT = <<<'EOT'
  /* This file is automatically generated by {@link BuildMetadataPHPFromXml}.
   * Please don't modify it directly.
   */


EOT;
    const MAP_COMMENT = <<<'EOT'
  // A mapping from a country code to the region codes which denote the
  // country/region represented by that country code. In the case of multiple
  // countries sharing a calling code, such as the NANPA countries, the one
  // indicated with "isMainCountryForCode" in the metadata should be first.

EOT;
    const COUNTRY_CODE_SET_COMMENT =
        "  // A set of all country codes for which data is available.\n";
    const REGION_CODE_SET_COMMENT =
        "  // A set of all region codes for which data is available.\n";

    public function start($argc, $argv)
    {
        if ($argc != 5 && $argc != 6) {
            echo self::HELP_MESSAGE;
            return false;
        }
        $inputFile = $argv[1];
        $outputDir = $argv[2];
        $filePrefix = $argv[3];
        $mappingClass = $argv[4];
        $liteBuild = $argc > 5 && $argv[5] === "true";

        $savePath = $outputDir . $filePrefix;

        $metadataCollection = BuildMetadataFromXml::buildPhoneMetadataCollection($inputFile, $liteBuild);

        $mappingClassLocation = __DIR__ . '/../src/libphonenumber/';

        $this->writeMetadataToFile($metadataCollection, $savePath);


        $countryCodeToRegionCodeMap = BuildMetadataFromXml::buildCountryCodeToRegionCodeMap($metadataCollection);

        // Sort $countryCodeToRegionCodeMap just to have the regions in order

        ksort($countryCodeToRegionCodeMap);

        $this->writeCountryCallingCodeMappingToFile($countryCodeToRegionCodeMap, $mappingClassLocation, $mappingClass);
    }

    /**
     * @param $metadataCollection PhoneMetadata[]
     * @param $filePrefix
     */
    private function writeMetadataToFile($metadataCollection, $filePrefix)
    {
        foreach ($metadataCollection as $metadata) {
            /** @var $phoneMetadata PhoneMetadata */
            $regionCode = $metadata->getId();
            // For non-geographical country calling codes (e.g. +800), use the country calling codes
            // instead of the region code to form the file name.
            if ($regionCode === '001' || $regionCode == '') {
                $regionCode = $metadata->getCountryCode();
            }

            $data = '<?php' . PHP_EOL . self::GENERATION_COMMENT . PHP_EOL . 'return ' . var_export(
                    $metadata->toArray(),
                    true
                ) . ';' . PHP_EOL . '/* EOF */';

            file_put_contents($filePrefix . "_" . $regionCode . '.php', $data);
        }
    }

    private function writeCountryCallingCodeMappingToFile($countryCodeToRegionCodeMap, $outputDir, $mappingClass)
    {
        // Find out whether the countryCodeToRegionCodeMap has any region codes or country
        // calling codes listed in it.
        $hasRegionCodes = false;
        foreach ($countryCodeToRegionCodeMap as $key => $listWithRegionCode) {
            if (count($listWithRegionCode) > 0) {
                $hasRegionCodes = true;
                break;
            }
        }

        $hasCountryCodes = (count($countryCodeToRegionCodeMap) > 1);

        $variableName = lcfirst($mappingClass);

        $data = '<?php' . PHP_EOL .
            self::GENERATION_COMMENT . PHP_EOL .
            "namespace libphonenumber;" . PHP_EOL .
            "class {$mappingClass} {" . PHP_EOL .
            PHP_EOL;

        if ($hasRegionCodes && $hasCountryCodes) {
            $data .= self::MAP_COMMENT . PHP_EOL;
            $data .= "   public static \${$variableName} = " . var_export(
                    $countryCodeToRegionCodeMap,
                    true
                ) . ";" . PHP_EOL;
        } elseif ($hasCountryCodes) {
            $data .= self::COUNTRY_CODE_SET_COMMENT . PHP_EOL;
            $data .= "   public static \${$variableName} = " . var_export(
                    array_keys($countryCodeToRegionCodeMap),
                    true
                ) . ";" . PHP_EOL;
        } else {
            $data .= self::REGION_CODE_SET_COMMENT . PHP_EOL;
            $data .= "   public static \${$variableName} = " . var_export(
                    $countryCodeToRegionCodeMap[0],
                    true
                ) . ";" . PHP_EOL;
        }

        $data .= PHP_EOL .
            "}" . PHP_EOL .
            '/* EOF */';

        file_put_contents($outputDir . $mappingClass . '.php', $data);
    }


}

$buildMetadataPHPFromXml = new BuildMetadataPHPFromXml();
$buildMetadataPHPFromXml->start($argc, $argv);
